Сортировка столбцов матрицы по max в столбцах

нужно поменять местами в матрице столбцы так чтобы макс элты в столбцах шли по возрастанию

сначала формируем в конце матрицы строку из мак элтов
потом эту строку сортируем и меняем с элтами целиком столбцы местами
используем сорт простым выбором

на каждом шаге находим очередной максимум и переставляем его в конец




	.model small
	.stack 100h
	.486 movzx чтобы можно было использовать
	.data
n	db 5
m	db 4
max	dw ? адрес начала строки максимумов
matrix	dw 70,60,50,40 матрица расположена по строкам в памяти
	dw 20,19,18,17
	dw 15,14,13,12
	dw 10,9,8,7
	dw 5,4,3,2
	dw 4 dup(?) место под строку максимумов
	.code
	mov ax,@data
	mov ds,ax
	mov es,ax для цепочечных команд
	cmp n,0 проверка допустимых значений
	jle er - здесь нельзя написать short, здесь near переход.
	cmp m,0
	jle er
	cld очищаем флаг направления, цепочечные команды впереже
	lea si,matrix загрузили адрес начала матрицы
	mov al,n количесство строк
	mov bl,m количество столбов, надо вычислить адрес начала строки с максиуммами
	imul bl
	shl ax,1 сдвигаем на 1 влево потому что матрица из слов ==> надо умножить на 2
	add ax,si, si - начало матрицы. Получили в ах смещение столбца максимальных элементов
	mov max,ax в мах будет храниться адрес начала строки с максимальными элементами
	mov di,ax - нужно сформировать в конце массив из максимальных элементов. Для начала скопируем туда первую строчку матрицы. Настроили di на последнюю строчку
	movzx cx,m занесли количество элементов в строке
	rep movsw m раз скопировали первую строку в конец. Нужно теперь пройти по всей матрице так, чтобы в этой строчке в конце оказались мак элементы
	movzx cx,n заносим число строк. Тут di сдвинулся. А si указывает на начало второй строки.
	dec cx для поиска максимума нужно n-1 итераций цикла. Цикл вложенный, потому что m столбцов и в каждом из них ищем максимум
cycm1:	push cx старый параметр цикла
	movzx cx,m новый параметр цикла - число столбцов
	mov di,max - адрес строки с максимальными элементами. si настраивать не нужно
параллельно ищем максимум по всем столбцам, в каждом массиве-столбце ищем макс элемент
cycm2:	cmpsw - сраниваем *si и *di. После этого si и di сдвинулись вперёд на два байта.
	jle short cycm3 - если очередной элемент меньше максимума, ниче не делаем. Иначе копируем вниз.
	dec si
	dec si
	dec di
	dec di - возвращаем все si и di назад
	movsw - записываем новый максимум, всё это - внутренний цикл. В нём мы идём по очередной строке матрицы и сравниваем элементы с макс иэлтами внизу.
cycm3:	loop cycm2
	pop cx
	loop cycm1 - внешний цикл. Так идём по всем строкам. в самом конце матрицы строка из максимальных элементов. теперь можно начать их сортировать
	movzx cx,m
	dec cx - сортировка простым выбором
Внешний цикл sort1 - m-1 раз. Мы найдём максимум и заменим с последним, потом с предпоследним и т.д.
sort1:	push cx - сортируем целые столбцы, в месте с сортировкой нижней строки матрицы. Это внешний цикл. Внутренний цикл выполняется сх-1 раз.
	mov si,max - загружаем адрес массива из мак элтов
	lodsw - загружаем очередной элемент массива из макс элементов. си сдвинулся на слово вперёд., загружается в ах
	mov dx,ax сохранили в dx тот, что только что загрузили. Первый элемент просто запоминаем, чтобы с ним сравнивать.
	xor bx,bx обнулили. Запомнили позицию первого элементам.
Во внутр цикле ищем максимум, чтобы его заменить
sort2:	lodsw следующий загрузили - извлекаем очередной
	cmp ax,dx - сравн с текущ макс
	jle short sort3
	mov dx,ax - новый максимум в dx и дальше вычисляем его номер:
	pop bx извлекаем общее количество итераций
	push bx - bx - тот элемент, который меняем. Сх - с которым меняем.
	sub bx,cx - узнали номер текущей итерации, то есть номер нового максимума
	inc bx
пройти по всему массиву и в регистре dx формируется текущий максимум, а в bx его позиция. Теперь этот элемент надо поменять с текущим последним - с тем,
у которого номер cx
sort3:	loop sort2
	pop cx 
	push cx надо поменять не только два элемента, но и все столбцы
	xor si,si
	xor di,di
	add si,bx; si = bx * 2 - известна позиция, а адрес - умноженный на два (потому что слово) - позиция текущего максимума
	add si,bx 
	add di,cx 
	add di,cx позиция куда нужно поместить. Полсучили в si позицию текущего макс, в di - текущего посл элта. Надо поменять столбцы, в которых находятся
эти эоты и надо найти адреса этих столбцов
	lea bx,matrix
	movzx cx,n 
	inc cx надо ещё не забыть последнюю строку переставить
	movzx dx,m количество столбцов чтобы вычислить смещение для перехода к следующим элементами с этих столбцах, то есть надо перейти на строку вниз
	shl dx,1 получили количество столбцов умноженное на два чтобы передвигаться на строку вниз
col:	mov ax,[bx+si] меняем местами столбцы в цикле. вх движется по строкам и указывает на начало первой строки.
	push word ptr [bx+di]
	pop word ptr [bx+si] 
	mov [bx+di],ax поменяли местами столбцы di и si - поменяли местами элементики в одной строке из соответствующих столбцов
	add bx,dx спустились к след строке и опять меняем столбцы местами
	loop col
	pop cx восстановили внешний цикл
	loop sort1 - пройдём полностью сортировку
	mov ax,4c00h
ex:	int 21h
er:	mov ax,4c01h - ошибка, код завершения программы отличен от нуля
	jmp ex
	end
