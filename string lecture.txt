Записать символы во всех словах в строке в обратном порядке, между словами оставить по одному пробелу, 
в начале строки и в конце строки не должно быть пробелов. Под словами понимается последовательность символов,
 ограниченных пробелом

	.model small
	.stack 100h
	.data
string	db 'xcdr a abdr    edr  zaq aqw  jgh t qwe',0 - результат формируем на месте. Строка null-ограниченная, как в Си.
	.code
	mov ax,@data - нету команды для записи непосредственного значения в сегментные регистры.
	Поэтому мы загружаем в ds адрес начала сегмента data, умноженного на 16 через промежуточный регистра ax.
	mov ds,ax
	mov es,ax - используем при работе цепочечные команды.
	cld
	lea si,string, si - source index
	lea di,string - загружаем смещение строки string относительно начала сегмента данных.
	xor bx,bx
	xor cx,cx

cx накапливает длину слова, переворачивать слово будем через стек.
bx - флаг достижения конца строки.

m1:	lodsb - считываем очередной символ исходной строки, обработка по принципу автомата.

	cmp al,0 - не достигли ли мы конца строки?
	je m2
	cmp al,' ' - если это пробел
	je m3

сейчас буква слова. Надо её поместить в стек.	
	
	push ax
	inc cx - увеличиваем счётчик на единицу
	jmp m1 - возвращаемся на начало к считыванию следуюего символа
m2:	mov bx,1 - было последнее слово, надо вообще выходить
m3:	jcxz m5 - если у нас пробел, то слово могло закончиться. Нужно его извлечь из стека и записать наоборот. А могло быть
два пробела.

	cmp di,offset string - в стеке есть некоторое слово. В начале строки не должно быть пробелов ==> мы должны перед каждым словом
	вставить пробел, кроме первого слова. Если di == offset string, мы в строку ещё ничего не писали, и пробел вставлять пока не надо.
	je m4
	mov al,' '
	stosb
m4:	pop ax - извлекаем слово из стека. Счётчик в cx, так что cx раз у нас выполнится цикл m4. 
	stosb
	loop m4
m5:	cmp bx,1 - если не конец строки, считываем следующий символ
	jne m1
	mov al,0 - заносим в строку нуль-байт
	stosb - запись по регистру di из регистра al (в результирующую строку), увеличит di (destination index)
	mov ax,4c00h
	int 21h
	end

	Отсортировать слова в строке по алфавиту, между словами оставить по одному пробелу, в начале строки и в конце строки не
	должно быть пробелов. Под словами понимается последовательность символов, ограниченных пробелом или табулятором

.model small
	.stack 100h
	.data
ptrs	dw 50 dup(?) - массив слов так как хранятся смещения
lens	db 50 dup(?) - массив длин слов, байты для усложнения

за первый проход формируем массив указателей на начало слов и массив длин слов
потом сортируем эти указатели в алфавитном порядке слов
потом по указателям соберём новую строку из слов

если мы хотим зарезервировать несколько байт, пишем dup(?). Фактически как выделение памяти

n	db ? - количество слов
delim	db ' ',9,0 - массив разделителей: пробел и табуляция.
string	db 'xcdr a abdr    edr  zaq aqw  jgh t qwe easrtyu zeq',0  - исходная строка
newstring db 100 dup(?) - место, куда помещается результирующая строка
	.code
	mov ax,@data
	mov ds,ax - указывает на исходную строку
	mov es,ax - указывает на результирующую строку
	cld
	
	мы должны сформировать массив указателей на начала слов и массив длин слов.
	
	lea si,string - ссылка на исходную строку
	lea di,delim - ссылка на начало строки разделителей.
	xor bx,bx, bx - счётчик слов
	
каждый раз надо найти начало очередного слова.
space принимает si на начало последовательности разделителей.
Она пропускает все разделители и после возврата si будет указывать на первый символ после последовательности разделителей.
То есть после вызова space si будет указывать на начало очередного слова.

m1:	call space
	cmp byte ptr [si],0 - если мы наткнулись на конец строки при попытке найти очередное слово.
	Надо обязательно написать, что сравниваем байт ==> byte ptr. Потому что непонятно, что такое 0 - то ли слово, то ли байт.
	je m2 - если достигли конца строки
	shl bx,1 - встретили начало очередного слова. Начало этого слова надо запомнить. 
	bx - счётчик слов, вначале равен нулю. Это фактически индекс в массиве, но его надо умножать на два, так как там массив слов.
	мы нашли начало очередного слова. bx указывает на индекс, умножаем его на два.
	mov ptrs[bx],si - заносим адрес в соответствующий элемент массива ptrs. 
	shr bx,1 - опять bx остался счётчиком слов. Надо посчитать длину слова.
	mov cx,si - запоминаем адрес начала слова.
	call words - функция похожа на space. Она пропускает слово и возвращает si, указывающий на первый разделитель после слова.
	Это может быть либо разделитель, либо нуль-байт
	sub cx,si - получили в cx длину слова с противоположным знаком.
	neg cx - теперь в cx нормальная длина слова.
	mov lens[bx],cl - записываем длину слова в массив длин. Но cx - слово, а cl - байт.
	inc bx - засчитали это слово.
	cmp byte ptr [si],0 - проверка. Нуль-байт может встретиться и после слова.
	jne m1 - нуль-байт не встретился, зацикливаемся. Иначе идём дальше.
m2:	mov n,bl
	push bx
	push offset lens
	push offset ptrs
	call sort - процедура принимает три параметра через стек.
	add sp,6 - очищаем стек, вытолкнули три параметра из стека.
	
	Теперь можем формировать новую строку.
	
	mov cx,bx - количество слов
	xor bx,bx - обнулим, с его помощью удобно индексироваться 
	lea di,newstring - будем писать в новую строку
m3:	push cx - запоминаем сх, чтобы использовать его потом для внутреннего вложенного цикла
	or bx,bx - проверка, не была ли у нас пустая строка. Если нулевое слово, перед ним вставлять пробел не нужно.
	je m4
	mov al,' '
	stosb - вставка пробела
m4:	shl bx,1 - нужно получить адрес начала слова, чтобы его копировать.
Регистр di уже указывает, куда нужно. Надо настроить si.
	mov si,ptrs[bx] - настроили, занесли адрес начала слова
	shr bx,1 - вернулись назад
	mov cl,lens[bx] - здесь можно написать movzx cx, len[bx] в 486. Занесли длину очередного слова в cx.
	xor ch,ch
	rep movsb - скопировали символы cx раз.
	inc bx - мы посчитали слово
	pop cx - вытаскиваем длину слова
	loop m3 - обрабатываем следующее слово
	xor al,al - получаем ноль в al
	stosb - закрываем строку нулевым байтом
	mov ax,4c00h
	int 21h
space	proc - имя процедуры, ключевое слово proc
	locals @@ - указываем префикс для локальных меток, действующий в пределах процедуры.
	
	si - рабочий регистр процедуры. 
	Но другие регистры портить не надо.
	
	push ax
	push cx - сохраняем регистры, потому что их испортим.
	push di - сохраним в стеке для себя
	xor al,al - обнуляем al. Мы будем искать разделитель. Сейчас si указывает на очередной символ.
	
	Мы должны проверить, не является ли он разделителем, то есть сравнить его с каждым разделителем.
	Для начала найдём число разделителей.
	
	mov cx,65535
	repne scasb - ищем нолик. 
	neg cx - вышли, когда нашли нулбайт ==> надо изменить знак cx. Таким образом, получили длину массива разделителей плюс один.
	
	
	
	dec cx
	push cx
@@m1:	pop cx
	pop di
	push di
	push cx
	lodsb - извлекаем очередной символ из исходной строки. Пытаемся его найти в массиве разделителей.
	repne scasb
	jcxz @@m2 Если мы его найдём, мы выйдем до обнуления cx. Если попали на m2, то разделителя нет.
	jmp @@m1 - извлекаем очередной символ.
@@m2:	dec si. Тут si указывает на символ, следующий после символа, не являющимся разделителем. Надо его вернуть назад,
потому что lodsb его уже увеличило.
	add sp,2 - в стеке хранится лишняя информация, лишний cx. Можно сделать pop cx, но это будет pop вникуда, потому что
	потом мы всё равно загрузим исходный cx.
	pop di - восстановили начальное состояние регистров
	pop cx
	pop ax
	ret - возврат из процедуры
	endp	- конец процедуры
words	proc
	locals @@
	push ax
	push cx
	push di
	xor al,al
	mov cx,65535
	repne scasb
	neg cx
	дек не делаем, потому что будем искать не только пробел с табуляциями, но ещё и с нуль-байтом.
	push cx
@@m:	pop cx извлекаем из стека длину массива
	pop di извлкаем начало массива разделителей
	push di
	push cx
	lodsb
	repne scasb
	jcxz @@m если cx = 0, мы продолжаем, то есть символ не разделитель
	dec si надо вернуть si
	add sp,2 в стеке опять один лишний символ
	pop di
	pop cx
	pop ax
	ret
	endp
sort	proc

можно написать c, a: word, b: word, d: word

	locals @@
	push bp чтобы обращаться к сегменту стека. 
	mov bp,sp теперь можно адресоваться к стеку. sp указывает на первую занятую ячейку. bp + 2 указывает на bp.
	
	строки 209 и 210 - стандартные для процедур.
	
	[bp+4] - первый параметр
	[bp+6] - второй параметр
	[bp+8] - третий параметр
	
	push ax
	push bx
	push cx
	push si
	push di
	
	пушим все регистры, потому что их можно испортить
	
	
	mov cx,[bp+8] - занесли количество элементов в массиве для сортировки.
	
	Сортировка выбором.
	
	dec cx
@@m1:	push cx - вложенный цикл, сохраняем параметр цикла.
	xor si,si - указываем на текущий максимальный
	xor di,di - ходим по массиву
	
	
	
	
@@m2:	inc di
	mov bx,[bp+6]
	mov ah,[bx+si]
	mov al,[bx+di]
	push ax
	mov bx,[bp+4]
	add bx,di
	add bx,di
	push word ptr [bx]
	mov bx,[bp+4]
	add bx,si
	add bx,si
	push word ptr [bx]
	call compare. Принимает: адрес первого, адрес второго и слово длина первого:длина второго, сравнивает два слова в лексикогра-
	фическом порядке.
	add sp,6
	cmp ax,-1
	jne @@m3
	mov si,di
@@m3:	loop @@m2
	cmp si,di
	je @@m4
	mov bx,[bp+6]
	mov ah,[bx+si]
	xchg ah,[bx+di]
	mov [bx+si],ah
	mov bx,[bp+4] 
	shl si,1
	shl di,1
	mov bx,[bp+4]
	push word ptr [bx+si]
	push word ptr [bx+di]
	pop word ptr [bx+si]
	pop word ptr [bx+di]
@@m4:	pop cx
	loop @@m1
	pop di
	pop si
	pop cx
	pop bx
	pop ax
	pop bp
	ret
	endp
compare proc
	locals @@
	push bp
	mov bp,sp
	push bx
	push cx
	push si
	push di
	mov si,[bp+4]
	mov di,[bp+6]
	mov ax,[bp+8]
	cmp ah,al
	jg @@m1
	mov cl,ah
	jmp short @@m2
@@m1:	mov cl,al
@@m2:	xor ch,ch
	repe cmpsb
	je @@m4
@@m3:	jg @@m5
	jmp short @@m6
@@m4:	cmp ah,al
	jne @@m3
	xor ax,ax
	jmp short @@m7
@@m5:	mov ax,1
	jmp short @@m7
@@m6:	mov ax,-1	
@@m7:	pop di
	pop si
	pop cx
	pop bx
	pop bp
	ret
	endp
	end

